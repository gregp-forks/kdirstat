diff -c -r -N kdirstat/Makefile.am /tmp/kd8/Makefile.am
*** kdirstat/Makefile.am	Mon Jun 18 13:00:35 2001
--- /tmp/kd8/Makefile.am	Thu Jun 21 00:52:09 2001
***************
*** 7,13 ****
  bin_PROGRAMS = kdirstat
  
  kdirstat_SOURCES = 				\
! 	ktreemap.cpp				\
  	kdirtree.cpp				\
  	kdirtreeview.cpp			\
  	kdirsaver.cpp				\
--- 7,14 ----
  bin_PROGRAMS = kdirstat
  
  kdirstat_SOURCES = 				\
! 	qtreemapwindow.cpp				\
! 	qtreemaparea.cpp				\
  	kdirtree.cpp				\
  	kdirtreeview.cpp			\
  	kdirsaver.cpp				\
***************
*** 16,22 ****
  	kdirstatmain.cpp
  
  noinst_HEADERS =				\
! 	ktreemap.h				\
  	kdirtree.h				\
  	kdirtreeview.h				\
  	kdirsaver.h				\
--- 17,23 ----
  	kdirstatmain.cpp
  
  noinst_HEADERS =				\
! 	qtreemap.h				\
  	kdirtree.h				\
  	kdirtreeview.h				\
  	kdirsaver.h				\
diff -c -r -N kdirstat/kdirstatapp.cpp /tmp/kd8/kdirstatapp.cpp
*** kdirstat/kdirstatapp.cpp	Mon Jun 18 13:00:35 2001
--- /tmp/kd8/kdirstatapp.cpp	Thu Jun 21 01:16:17 2001
***************
*** 25,31 ****
  
  #include "kdirstatapp.h"
  #include "kpacman.h"
- #include "ktreemap.h"
  
  #define ID_STATUS_MSG 1
  
--- 25,30 ----
***************
*** 58,65 ****
      // disable actions at startup
      editCopy->setEnabled( false );
  
-     //    _treemap_view=new KDirStat::KTreeMap(this);
-     //_treemap_view=new KDirStat::KTreeMap(this);
  }
  
  KDirStatApp::~KDirStatApp()
--- 57,62 ----
diff -c -r -N kdirstat/kdirstatapp.h /tmp/kd8/kdirstatapp.h
*** kdirstat/kdirstatapp.h	Mon Jun 18 13:00:35 2001
--- /tmp/kd8/kdirstatapp.h	Thu Jun 21 01:15:29 2001
***************
*** 26,35 ****
  #include <kaccel.h>
  #include <kaction.h>
  #include "kdirtreeview.h"
- #include "ktreemap.h"
  
  class KPacMan;
- //class KDirStat::KTreeMap;
  
  /**
    * The base class for KDirStat application windows. It sets up the main window
--- 26,33 ----
***************
*** 209,215 ****
      KToggleAction * 		viewToolBar;
      KToggleAction * 		viewStatusBar;
  
-     KDirStat::KTreeMap  *_treemap_view;
  };
  
   
--- 207,212 ----
diff -c -r -N kdirstat/kdirtreeview.cpp /tmp/kd8/kdirtreeview.cpp
*** kdirstat/kdirtreeview.cpp	Mon Jun 18 13:00:35 2001
--- /tmp/kd8/kdirtreeview.cpp	Thu Jun 21 01:09:40 2001
***************
*** 24,30 ****
  
  #include "kdirtreeview.h"
  #include "kpacman.h"
! #include "ktreemap.h"
  
  using namespace KDirStat;
  
--- 24,30 ----
  
  #include "kdirtreeview.h"
  #include "kpacman.h"
! #include "qtreemap.h"
  
  using namespace KDirStat;
  
***************
*** 103,109 ****
     connect ( kapp,	SIGNAL	( kdisplayPaletteChanged()	),
  	     this, 	SLOT	( paletteChanged()		) );
  	
!    _treemap_view=new KDirStat::KTreeMap();
  }
  
  
--- 103,109 ----
     connect ( kapp,	SIGNAL	( kdisplayPaletteChanged()	),
  	     this, 	SLOT	( paletteChanged()		) );
  	
!    _treemap_view=new KDirStat::QTreeMapWindow();
  }
  
  
***************
*** 141,147 ****
      }
  
      //_treemap_view->drawTreeMap(_tree->root());
!     _treemap_view->setTreeMap((KDirInfo *)_tree->root());
  }
  
  
--- 141,147 ----
      }
  
      //_treemap_view->drawTreeMap(_tree->root());
!     _treemap_view->getArea()->setTreeMap((KDirInfo *)_tree->root());
  }
  
  
diff -c -r -N kdirstat/kdirtreeview.h /tmp/kd8/kdirtreeview.h
*** kdirstat/kdirtreeview.h	Mon Jun 18 13:00:35 2001
--- /tmp/kd8/kdirtreeview.h	Thu Jun 21 00:53:44 2001
***************
*** 33,39 ****
  #include <qpixmap.h>
  #include <klistview.h>
  #include "kdirtree.h"
! #include "ktreemap.h"
  
  // Forward declarations
  class QWidget;
--- 33,39 ----
  #include <qpixmap.h>
  #include <klistview.h>
  #include "kdirtree.h"
! #include "qtreemap.h"
  
  // Forward declarations
  class QWidget;
***************
*** 344,350 ****
  	QPixmap	_workingIcon;
  	QPixmap	_readyIcon;
  	
! 	KTreeMap  *_treemap_view;
      };
  
      
--- 344,350 ----
  	QPixmap	_workingIcon;
  	QPixmap	_readyIcon;
  	
! 	QTreeMapWindow  *_treemap_view;
      };
  
      
diff -c -r -N kdirstat/ktreemap.cpp /tmp/kd8/ktreemap.cpp
*** kdirstat/ktreemap.cpp	Tue Jun 19 05:41:50 2001
--- /tmp/kd8/ktreemap.cpp	Thu Jan  1 01:00:00 1970
***************
*** 1,638 ****
- /*
-  *   File name:	ktreemap.cpp
-  *   Summary:	Support classes for KDirStat
-  *   License:	LGPL - See file COPYING.LIB for details.
-  *   Author:	Alexander Rawass <alexannika@users.sourceforge.net>
-  *
-  *   Updated:	2001-06-10
-  *
-  *   $Id: kd8.diff,v 1.1 2001/06/29 13:20:18 hundhammer Exp $
-  *
-  */
- 
- 
- #include <string.h>
- #include <sys/errno.h>
- #include <math.h>
- #include <stdlib.h>
- #include <unistd.h>
- #include <qtimer.h>
- #include <kdebug.h>
- #include <kapp.h>
- #include <klocale.h>
- #include "kdirtree.h"
- #include "kdirtreeview.h"
- #include "kdirsaver.h"
- #include "ktreemap.h"
- #include <qmainwindow.h>
- 
- using namespace KDirStat;
- 
- KDirStat::KTreeMap::KTreeMap(  )  : QMainWindow() {
-   initOptions();
-   //tooltip=new DynaTip(this);
-   //QToolTip::add(this,"KTreeMap");
- 
-   popup=new QPopupMenu(this);
-   popup_id=popup->insertItem(QString("you"));
- 
-   info_box=new QVBox(this);
-   dir_box=new QHBox(info_box);
- 
-   dir_name_label=new QLabel("toplevel",dir_box);
-   up_button=new QPushButton("Up",dir_box);
- 
-   info_label=new QLabel("information",info_box);
- 
-   test_button=new QPushButton("test",info_box);
- 
-   //graph_widget=new QWidget(info_box);
-   graph_widget=this;
- 
-   info_box->show();
-   dir_box->show();
-   info_label->show();
-   graph_widget->show();
-   graph_widget->resize(options->paint_size_x,options->paint_size_y);
- 
-   QObject::connect(up_button, SIGNAL(clicked()), this, SLOT(buttonUp()));
- 
-   this->show();
-   this->resize(options->paint_size_x,options->paint_size_y);
- 
-   default_color=QColor(255,255,255);
- 
-   offscreen= QPixmap(options->paint_size_x,options->paint_size_y);
- 
-   painter=new QPainter(&offscreen);
-   win_painter=new QPainter(graph_widget);
- 
-   setMouseTracking(TRUE);
-   root_tree=NULL;
- 
-   color_index=0;
-   
-   rotate_colors[0]=QColor(255,0,0);
-   rotate_colors[1]=QColor(255,255,0);
-   rotate_colors[2]=QColor(255,0,255);
-   rotate_colors[3]=QColor(0,255,0);
-   rotate_colors[4]=QColor(0,0,255);
- #define LAST_ROTATING_COL 4
- 
- }
- 
- int KTreeMap::getNextRotatingColorIndex(){
-   color_index++;
-   if(color_index>LAST_ROTATING_COL){
-     color_index=0;
-   }
-   return color_index;
- }
- 
- void KTreeMap::setTreeMap(KDirInfo *dutree){
-   root_tree=dutree;
- 
-   drawTreeMap(dutree);
- }
- 
- void KTreeMap::initOptions(){
- 
-   options=new KTreeMapOptions();
- 
-   options->draw_mode=DM_BOTH;
-   options->paintmode=PM_FLAT;
-   options->start_direction=HORIZONTAL;
-   options->step_width=0;
-   options->paint_size_x=800;
-   options->paint_size_y=500;
-   options->highlight_frame_width=3;
-   options->highlight_frame_col=QColor(255,255,255);
-   options->dont_draw_xyd=1;
-   options->dont_descend_xyd=1;
-   options->draw_text=TRUE;
-   options->color_scheme=CS_CYCLIC;
- }
- 
- void KTreeMap::drawTreeMap(KDirInfo *dutree){
-   int x0=0;
-   int y0=0;
-   int xd0=options->paint_size_x;
-   int yd0=options->paint_size_y;
- 
-   color_index=0;
- 
-   painter->end();
-   painter->begin(&offscreen);
-   painter->setWindow(x0,y0,xd0,yd0);
-   painter->setFont(QFont( "times",10));
- 
-   Cushion *cushion=NULL;
-   if(options->paintmode==PM_CUSHION){
-     cushion=new Cushion(xd0,yd0);
-   }
-   else{
-     cushion=NULL;
-   }
-     drawDuTree(dutree,x0,y0,xd0,yd0,options->start_direction,0,cushion);
- 
-     this->update();
-     this->repaint();
-     graph_widget->repaint();
- }
- 
- void KTreeMap::drawDuTree(KDirInfo *dutree, int x0,int y0,int xd0, int yd0, bool direction, int level,Cushion *cushion,int fx=-1,int fy=-1,int findmode=FIND_NOTHING){
-   QString node_name=dutree->debugUrl();
-   KDirInfo *sub_nodes=(KDirInfo *)dutree->firstChild();
-   int node_totalsize=dutree->totalSize();
-   Cushion *c=NULL;
- 
-   //    printf("KTreeMap::drawDuTree(%s,%d,%d,%d,%d,dir=%d,level=%d) %d\n",node_name.latin1(),x0,y0,xd0,yd0,direction,level,node_totalsize);
- 
-   if(xd0>=options->dont_draw_xyd && yd0>=options->dont_draw_xyd){
-   if(fx>=0 && fy>=0){
-     // search mode
-     if( ( x0<=fx && fx<=(x0+xd0) ) && ( ( y0<=fy && fy<=(y0+yd0)) ) ){
-       // mouse coord are inside this entries coordinates
-       found_kfileinfo=dutree;
-       if(findmode==FIND_FIRSTDIR && dutree!=root_tree){
- 	// we have found the first directory with this coordinates
- 	return;
-       }
-     }
-     else{
-       // don't descend into this part of tree
-       return;
-     }
-   }
-   else{
-     // not in search mode
-     if(cushion!=NULL){
-       c=new Cushion(*cushion);
-       if(dutree!=root_tree){
- 	cushion_AddRidge(c->r[direction][0],
- 			 c->r[direction][1],
- 			 c->h,
- 			 c->s[direction][1],
- 			 c->s[direction][2]);
-       }
-     }
-     else{
-       c=NULL;
-     }
-   }
- 
-   if((options->draw_mode==DM_FILES || options->draw_mode==DM_BOTH )&& dutree->isFile() /* && (fx==-1 && fy==-1) */ ){
- 	QColor basecolor;
- 	//basecolor=getBaseColor(node_name);
- 	basecolor=QColor(rotate_colors[color_index]);
- 	int index=getNextRotatingColorIndex();
- 
- 	int pmode;
- 	if((fx>=0 && fy>=0)){
- 	  // when searching, only draw outline
- 	    pmode=PM_OUTLINE;
- 	    if(dutree==found_kfileinfo){
- 	      paintEntry(x0,y0,xd0,yd0,node_name,direction,level,options->highlight_frame_col,pmode,c);
- 	  }
- 	}
- 	else{
- 	  // really draw this entry
- 	  pmode=options->paintmode;
- 	  paintEntry(x0,y0,xd0,yd0,node_name,direction,level,basecolor,pmode,c);
- 	}
- 
-       }
-       else if((options->draw_mode==DM_DIRS || options->draw_mode==DM_BOTH) && ( dutree->isDir() || dutree->isDotEntry())) {
- 	QColor basecolor=QColor(rotate_colors[color_index]);
- 	QColor dircolor=QColor(basecolor.red()/3,
- 			       basecolor.green()/3,
- 			       basecolor.blue()/3);
- 	int index=getNextRotatingColorIndex();
- 
- 	KDirInfo *dirinfo=(KDirInfo *)dutree;
- 
- 	int pmode;
- 	if(fx>=0 && fy>=0){
- 	  // draw outline in search mode
- 	  pmode=PM_OUTLINE;
- 	  if(dutree==found_kfileinfo){
- 	    paintEntry(x0,y0,xd0,yd0,node_name,direction,level,options->highlight_frame_col,pmode,c);
- 	  }
- 	}
- 	else{
- 	  // draw the rectangle
- 	  pmode=options->paintmode;
- 	  paintEntry(x0,y0,xd0,yd0,node_name,direction,level,dircolor,pmode,c);
- 	}
-       }
-       else{
- 	// we've found a symbolic link or like that
- 	//printf("neither file nor dir %s\n",node_name.latin1());
- 	// do nothing?
-       }
-       
-       float x=(float)x0;
-       float y=(float)y0;
-       float xd=0.0;
-       float yd=0.0;
-       float w=0.0;
- 
-       if(c!=NULL){
- 	// cushion mode
- 	w=( c->r[direction][1] - c->r[direction][0] )/((float)node_totalsize);
-       }
-       for(KDirInfo *subtree=sub_nodes;subtree!=NULL;subtree=(KDirInfo *)subtree->next()){
- 	int subnode_size=subtree->totalSize();
- 	  if(subnode_size==0){
- 	    // we do not descend in directories with 0 size
- 	  }
- 	  else{
- 	    float percent_size=((float)subnode_size)/((float)node_totalsize);
- 	    
- 	    if(direction==HORIZONTAL){
- 	      // horizontal
- 	      xd=(float)xd0;
- 	      yd=(float)(((float)yd0)*percent_size);
- 	    }
- 	    else{
- 	      // vertikal
- 	      xd=(float)(((float)xd0)*percent_size);
- 	      yd=(float)yd0;
- 	    }
- 	    bool subdirection=!direction;
- 	    
- 	    int sw=options->step_width;
- 
- 	    if(c!=NULL){
- 	      c->r[direction][1]=c->r[direction][0] + ( w*((float)subnode_size) );
- 	      c->h=c->h*c->f;
- 	    }
- 	    
- 	    drawDuTree(subtree,(int)x,(int)y,(int)(xd-sw),(int)(yd-sw),subdirection,level+1,c,fx,fy,findmode);
- 
- 	    if(c!=NULL){
- 	      c->r[direction][0]=c->r[direction][1];
- 	    }
- 
- 	    if(direction==HORIZONTAL){
- 	      // horizontal
- 	      y=y+yd;
- 	    }
- 	    else{
- 	      x=x+xd;
- 	    }
- 	  }
-       }
- 
-       if( dutree->dotEntry()!=NULL ){
- 	KDirInfo *dotentry=(KDirInfo *)dutree->dotEntry();
- 	int subnode_size=dotentry->totalSize();
- 	    float percent_size=((float)subnode_size)/((float)node_totalsize);
- 	    
- 	    if(direction==HORIZONTAL){
- 	      // horizontal
- 	      xd=(float)xd0;
- 	      yd=(float)(((float)yd0)*percent_size);
- 	    }
- 	    else{
- 	      // vertikal
- 	      xd=(float)(((float)xd0)*percent_size);
- 	      yd=(float)yd0;
- 	    }
- 	    bool subdirection=direction;
- 	    
- 	    int sw=options->step_width;
- 
- 	    drawDuTree(dotentry,(int)x,(int)y,(int)(xd-sw),(int)(yd-sw),subdirection,level,c,fx,fy,findmode);
-       }
-   }
- }
- 
- void KTreeMap::paintEntry(int x0, int y0, int xd, int yd,QString entry_name,bool direction,int level,const QColor &basecolor,int pmode,Cushion *c){
- 
- #define MPIX 1
- 
-   if(xd<=MPIX || yd<=MPIX){
-     if(xd<=MPIX){
-       xd=MPIX;
-     }
-     if(yd<=MPIX){
-       yd=MPIX;
-     }
-   }
- 
- #if 0
-       mypen.setColor(QColor(0,255,0));
-       mypen.setWidth( 4);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
- 
-     painter->drawLine(x0,y0,x0+xd,y0+yd);
- #endif
- 
-   if(pmode==PM_OUTLINE){
-     // draw highlighted frames in search mode
-     mypen.setColor(basecolor);
-     mypen.setWidth(options->highlight_frame_width);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
- 
-     painter->drawRect(x0,y0,xd,yd);
-     //painter->flush();
-   }
-   else if(pmode==PM_FLAT){
-     painter->fillRect(x0,y0,xd,yd,basecolor);
-     //painter->flush();
-   }
-   else if(pmode==PM_PYRAMID){
-     int step=0;
-     int maxstep;
- 
-     if(xd>yd){
-       maxstep=yd/2;
-     }
-     else{
-       maxstep=xd/2;
-     }
- 
-     while(step<maxstep){
-       QColor color=QColor((basecolor.red()/maxstep)*(maxstep-step),
- 			  (basecolor.green()/maxstep)*(maxstep-step),
- 			  (basecolor.blue()/maxstep)*(maxstep-step));
-       mypen.setColor(color);
-       mypen.setWidth( 1);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
-       // why does this drawRect not work?
-       // it draws only the left and upper side line
-       // but not the bottom and right side line
-       painter->drawRect(x0+step,y0+step,xd-step,yd-step);
-       //painter->flush();
-       step++;
-     }
-   }
-   else if(pmode==PM_SIMPLE_CUSHION){
-     for(int w=0;w<xd;w++){
-       for(int h=0;h<yd;h++){
- 	float ix=sin(((float)w)/((float)xd)*3.14f);
- 	float iy=sin(((float)h)/((float)yd)*3.14f);
- 	float i=(ix+iy)/2.0; // intensity as a sin in x/y direction
- 	QColor newcol=QColor((int)basecolor.red()*i,
- 			     (int)basecolor.green()*i,
- 			     (int)basecolor.blue()*i);
-       mypen.setColor(newcol);
-       mypen.setWidth( 1);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
- 	
-       painter->drawPoint(x0+w,y0+h);
-       //painter->flush();
-       }
-     }
-   }
-   else if(pmode==PM_BITMAP){
-   }
-   else if(pmode==PM_CUSHION && c!=NULL){
-     float Ia=40.0;
-     float Is=215.0;
-     float Lx=0.09759;
-     float Ly=0.19518;
-     float Lz=0.9759;
- 
-     //for(float iy=c->r[DY][0] + 0.5 ; iy<=( c->r[DY][1] - 0.5 );iy++){
-     //  for(float ix=c->r[DX][0] + 0.5 ; ix<=( c->r[DX][1] - 0.5 );ix++){
-     for(float iy=y0;iy<=y0+yd;iy++){
-       for(float ix=x0;ix<=x0+xd;ix++){
- 	float nx=-(2*c->s[DX][2]*(ix+0.5) + c->s[DX][1] );
- 	float ny=-(2*c->s[DY][2]*(iy+0.5) + c->s[DY][1] );
- 	float cosa=(nx*Lx + ny*Ly + Lz )/sqrt(nx*nx + ny*ny +1.0);
- 
- 	float Iscosa=Is*cosa;
- 	if(Iscosa<0.0){
- 	  Iscosa=0.0;
- 	}
- 	float i=Ia+Iscosa; // range?
- 	i=i/512.0;
- 	if(i>1.0){
- 	  i=1.0;
- 	}
- 	if(i<0.0){
- 	  i=0.0;
- 	}
- 	//printf("cushion: i=%f\n",i);
- 	QColor newcol=QColor((int)basecolor.red()*i,
- 			     (int)basecolor.green()*i,
- 			     (int)basecolor.blue()*i);
-       mypen.setColor(newcol);
-       mypen.setWidth( 1);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
- 
- 	painter->drawPoint((int)ix,(int)iy);
-       }
-     }
-       
-   }
-   else{
-     printf("KTreeMap::paintEntry no option\n");
-   }
- 
-   if(pmode!=PM_OUTLINE && options->draw_text){
-     // draw text inside rectangle if text fits
-       mypen.setColor(QColor(255,255,255));
-       mypen.setWidth( 1);
-       painter->setPen( mypen );
-       painter->setBrush( Qt::NoBrush );
- 
-       //if(direction==VERTIKAL && yd>5){
-     if(xd>=yd && yd>5){
-       int maxlen=xd/4;
-       QString end=entry_name.right(maxlen);
-       painter->drawText(x0,y0+8,end,maxlen);
-     }
-     //else if(direction==HORIZONTAL && xd>5){
-     else if(xd<yd && xd>5){
-       int maxlen=yd/4;
- 
-       // draw text rotated
-       painter->save();
-       painter->translate(x0,y0);
-       painter->rotate(90);
- 
- 
-       QString end=entry_name.right(maxlen);
-       painter->drawText( 0,0,end,maxlen);
-       painter->restore();
-     }
-   }
- }
- 
- QColor&  getBaseColor(QString name){
-   QColor basecolor;
- 	/*
- 	if(isExecutable()){
- 	  basecolor=NULL;
- 	}
- 	else{
- 	  basecolor=getBaseColorByName(node_name);
- 	}
- 	*/
-   basecolor=QColor( rand()&255 , rand()&255, rand()&255 );
- 
-   return basecolor;
- }
- 
- KDirInfo *KTreeMap::findClickedMap(KDirInfo *dutree,int x,int y,int findmode){
-   KDirInfo *found;
- 
-   found_kfileinfo=NULL;
- 
-   painter->end();
- 
-   // copy offscreen to widget
-   win_painter->begin(graph_widget);
-   win_painter->drawPixmap(0,0,offscreen,0,0,800,600);
-   win_painter->flush();
-   win_painter->end();
- 
-     // draw outlines on widget, not on offscreen
-     painter->begin(graph_widget);
-     drawDuTree(dutree,0,0,options->paint_size_x,options->paint_size_y,options->start_direction,0,NULL,x,y,findmode);
- 
-   //printf("FOUND: %s\n",found_kfileinfo->debugUrl().latin1());
- 
-     painter->drawText(x,y,found_kfileinfo->debugUrl());
-     QToolTip::add(this,found_kfileinfo->debugUrl());
- 
-   return found_kfileinfo;
- }
- 
- void KTreeMap::paintEvent( QPaintEvent *event){
-   if(root_tree!=NULL){
-     QRect event_rect=event->rect();
- 
-     painter->end(); // end painting on offscreen
- 
-     // copy offscreen to widget
-     win_painter->begin(graph_widget);
-     win_painter->drawPixmap(0,0,offscreen,0,0,800,600);
-     win_painter->flush();
-     win_painter->end();
- 
-     painter->begin(graph_widget);
-   }
- }
- 
- void KTreeMap::mouseDoubleClickEvent(QMouseEvent *mouse){
-   if(root_tree!=NULL){
-     int x=mouse->x();
-     int y=mouse->y();
-     if( (0<=x && x<=options->paint_size_x) && (0<=y && y<=options->paint_size_y)){
-       // find the first dir (the first coord. matching entry) the mouse points to
-       KDirInfo *found=findClickedMap(root_tree,x,y,FIND_FIRSTDIR);
-       
-       if(found!=NULL){
- 	// draw the new map
- 	setTreeMap(found);
-       }
-     }
-   }
- }
- 
- void KTreeMap::mouseMoveEvent(QMouseEvent *mouse){
-   if(root_tree!=NULL){
-     int x=mouse->x();
-     int y=mouse->y();
-     if( (0<=x && x<=options->paint_size_x) && (0<=y && y<=options->paint_size_y)){
-       // find the file (the last coord. matching entry) the mouse points to
-       KDirInfo *found=findClickedMap(root_tree,x,y,FIND_FILE);
-     }
-   }
- }
- 
- void KTreeMap::keyPressEvent(QKeyEvent *event){
-   QString key=event->text();
-   if(key==QString("u")){
-     directoryUp();
-   }
- }
- 
- void KTreeMap::resizeEvent( QResizeEvent *ev)
- {
-     // kdDebug() << k_funcinfo << endl;
-  
-     update();   // Trigger repaint on resize
- }
- 
- void KTreeMap::buttonUp(){
-   directoryUp();
- }
- 
- void KTreeMap::directoryUp(){
-   KDirInfo *parent=(KDirInfo *)root_tree->parent();
-   if(parent!=NULL){
-     setTreeMap(parent);
-   }
- }
- 
- void KTreeMap::cushion_AddRidge(float x1,float x2,float h,float& s1,float& s2){
-   s1=s1+4*h*(x2+x1)/(x2-x1);
-   s2=s2-4*h/(x2-x1);
- }
- 
- void KTreeMap::setOptions(KTreeMapOptions *opt){
-   delete options;
- 
-   options=new KTreeMapOptions(*opt);
- }
- 
- KTreeMapOptions *KTreeMap::getOptions(){
-   return options;
- }
- KTreeMap::~KTreeMap()
- {
-   // to be filled later...
- }
- 
- KTreeMapOptions::KTreeMapOptions(){
-   // do nothing
- }
- 
- KTreeMapOptions::~KTreeMapOptions(){
-   // do nothing
- }
- 
- 
- DynaTip::DynaTip(QWidget *parent) : QToolTip(parent)
- {
-   // no init
-   printf("Dynatip init\n");
- }
- 
- void DynaTip::maybeTip(const QPoint &pos){
-   printf("maybetip\n");
-   QRect rect=QRect(0,0,1024,700);
-   tip(rect,"blah");
- }
- 
- 
- Cushion::Cushion(int xd,int yd){
-   r[DX][0]=0.0;
-   r[DX][1]=(float)xd;
-   r[DY][0]=0.0;
-   r[DY][1]=(float)yd;
- 
-   s[DX][1]=0.0;
-   s[DX][2]=0.0;
-   s[DY][1]=0.0;
-   s[DY][2]=0.0;
- 
-   h=0.5;
-   f=0.75;
- }
- 
- /*
- Cushion::Cushion(Cushion *old){
-   
- }
- */
--- 0 ----
diff -c -r -N kdirstat/ktreemap.h /tmp/kd8/ktreemap.h
*** kdirstat/ktreemap.h	Tue Jun 19 05:43:58 2001
--- /tmp/kd8/ktreemap.h	Thu Jan  1 01:00:00 1970
***************
*** 1,198 ****
- /*
-  *   File name:	ktreemap.h
-  *   Summary:	Support classes for KDirStat
-  *   License:	LGPL - See file COPYING.LIB for details.
-  *   Author:	Alexander Rawass <alexannika@users.sourceforge.net>
-  *
-  *   Updated:	2001-06-11
-  *
-  *   $Id: kd8.diff,v 1.1 2001/06/29 13:20:18 hundhammer Exp $
-  *
-  */
- 
- #ifndef KTreeMap_h
- #define KTreeMap_h
- 
- 
- #ifdef HAVE_CONFIG_H
- #   include <config.h>
- #endif
- 
- #include <sys/types.h>
- #include <limits.h>
- #include <dirent.h>
- #include <qqueue.h>
- #include <kfileitem.h>
- #include <qmainwindow.h>
- #include "kdirtree.h"
- #include <qpen.h>
- #include <qtooltip.h>
- #include <qlabel.h>
- #include <qbutton.h>
- #include <qvbox.h>
- #include <qhbox.h>
- #include <qpushbutton.h>
- #include <qpopupmenu.h>
- 
- #ifndef NOT_USED
- #    define NOT_USED(PARAM)	( (void) (PARAM) )
- #endif
- 
- // Open a new name space since KDE's name space is pretty much cluttered
- // already - all names that would even remotely match are already used up,
- // yet the resprective classes don't quite fit the purposes required here.
- 
- namespace KDirStat
- {
- 
- #define PM_FLAT 0
- #define PM_SIMPLE_CUSHION 1
- #define PM_PYRAMID 2
- #define PM_BITMAP 3
- #define PM_PYRAMID_NICE_BUG 4
- #define PM_OUTLINE 5
- #define PM_CUSHION 6
- 
- #define DM_DIRS 0
- #define DM_FILES 1
- #define DM_BOTH 2
- 
- #define CS_CYCLIC 0
- 
- #define FIND_NOTHING 0
- #define FIND_FILE 1
- #define FIND_FIRSTDIR 2
- 
- #define HORIZONTAL 0
- #define VERTIKAL 1
- 
- #define DX HORIZONTAL
- #define DY VERTIKAL
- 
-   class KTreeMapOptions {
-   public:
-     KTreeMapOptions();
-     ~KTreeMapOptions();
-     
-     int   color_scheme;
-     int dont_draw_xyd;
-     int dont_descend_xyd;
-     int draw_mode;
-     int paintmode;
-     bool start_direction;
-     int step_width;
-     int paint_size_x;
-     int paint_size_y;
-     int highlight_frame_width;
-     QColor highlight_frame_col;
-     bool draw_text;
-   };
- 
-   class Cushion {
-   public:
-     Cushion(int xd,int yd);
-     //    Cushion(Cushion *old);
- 
-     float    r[2][2];
-     float    h;
-     float    f;
-     float    s[2][3];
-   };
- 
-   class KTreeMap : public QMainWindow {
-     Q_OBJECT
- 
-   public:
-     //KTreeMap(QWidget *parent=0);
-     KTreeMap();
-     ~KTreeMap();
- 
-     void drawTreeMap(KDirInfo *dutree);
-     void setTreeMap(KDirInfo *dutree);
-     KDirInfo *findClickedMap(KDirInfo *dutree,int x,int y,int findmode);
- 
-     void paintEvent(QPaintEvent *);
-     void mouseMoveEvent(QMouseEvent *);
-     void mouseDoubleClickEvent(QMouseEvent *);
-     void keyPressEvent(QKeyEvent *event);
- 
-     void setOptions(KTreeMapOptions *opt);
-     KTreeMapOptions *getOptions();
-     void  resizeEvent( QResizeEvent *ev);
-   private:
- 
-     void drawDuTree(KDirInfo *dutree, int x0,int y0,int xd0, int yd0, bool direction, int level,Cushion *cushion,int fx=-1,int fy=-1,int find_mode=FIND_NOTHING);
-     void paintEntry(int x0, int y0, int xd, int yd,QString entry_name,bool direction,int level,const QColor &basecolor,int pmode,Cushion *c);
-   
-     void initOptions();
- 
-   void appendRectlist(QString node_name,int x,int y,int xd,int yd);
-   int getNextRotatingColorIndex();
-   void directoryUp();
- 
-   QColor& getBaseColor(QString name);
- 
-   QPainter *painter;
-   KTreeMapOptions *options;
-   QColor default_color;
-   QWidget *widget;
-   QPen mypen;
-   QPixmap offscreen;
-   QPainter *win_painter;
- 
-   QColor rotate_colors[20];
-   int color_index;
- 
-   KDirInfo *root_tree;
- 
-   QToolTip *tooltip;
- 
-   QVBox *info_box;
-   QHBox *dir_box;
- 
-   QLabel *dir_name_label;
-   QLabel *info_label;
-   QPushButton *up_button;
- 
-   QWidget *graph_widget;
- 
-   QPushButton *test_button;
- 
-   QPopupMenu *popup;
-   int popup_id;
- 
-   KDirInfo *found_kfileinfo;
- 
-   // cushion rendering
- 
-   void cushion_AddRidge(float x1,float x2,float h,float& s1,float& s2);
- 
- #define R_MIN 0
- #define R_MAX 1
- 
-   float cushion_rectangle[2][2];
- 
- #define D_1 0
- #define D_2 1
- 
-   float cushion_surface[1][2];
- 
-   public slots:
-       void buttonUp();
-   };
- 
-   class DynaTip : public QToolTip {
-     //Q_OBJECT
- 
-   public:
-     DynaTip(QWidget *parent);
-   protected:
-     void maybeTip(const QPoint &);
-   };
- } // namespace
- 
- 
- #endif // ifndef KTreeMap_h
- 
- 
- // EOF
--- 0 ----
diff -c -r -N kdirstat/qtreemap.h /tmp/kd8/qtreemap.h
*** kdirstat/qtreemap.h	Thu Jan  1 01:00:00 1970
--- /tmp/kd8/qtreemap.h	Thu Jun 21 02:47:23 2001
***************
*** 0 ****
--- 1,283 ----
+ /*
+  *   File name:	ktreemap.h
+  *   Summary:	Support classes for KDirStat
+  *   License:	LGPL - See file COPYING.LIB for details.
+  *   Author:	Alexander Rawass <alexannika@users.sourceforge.net>
+  *
+  *   Updated:	2001-06-11
+  *
+  *   $Id: kd8.diff,v 1.1 2001/06/29 13:20:18 hundhammer Exp $
+  *
+  */
+ 
+ #ifndef QTreeMap_h
+ #define QTreeMap_h
+ 
+ 
+ #ifdef HAVE_CONFIG_H
+ #   include <config.h>
+ #endif
+ 
+ #include <sys/types.h>
+ #include <limits.h>
+ #include <dirent.h>
+ #include <qqueue.h>
+ #include <kfileitem.h>
+ #include <qtoolbar.h>
+ #include <qstatusbar.h>
+ #include <qmenubar.h>
+ #include <qmainwindow.h>
+ #include "kdirtree.h"
+ #include <qpen.h>
+ #include <qtooltip.h>
+ #include <qlabel.h>
+ #include <qbutton.h>
+ #include <qvbox.h>
+ #include <qhbox.h>
+ #include <qpushbutton.h>
+ #include <qpopupmenu.h>
+ #include <qradiobutton.h>
+ #include <qbuttongroup.h>
+ #include <qscrollview.h>
+ 
+ #ifndef NOT_USED
+ #    define NOT_USED(PARAM)	( (void) (PARAM) )
+ #endif
+ 
+ // Open a new name space since KDE's name space is pretty much cluttered
+ // already - all names that would even remotely match are already used up,
+ // yet the resprective classes don't quite fit the purposes required here.
+ 
+ namespace KDirStat
+ {
+ 
+   // paint modes
+ 
+ #define PM_FLAT 0
+ #define PM_SIMPLE_CUSHION 1
+ #define PM_PYRAMID 2
+ #define PM_BITMAP 3
+ #define PM_PYRAMID_NICE_BUG 4
+ #define PM_OUTLINE 5
+ #define PM_CUSHION 6
+ #define PM_SQUARE_CUSHION 7
+ #define PM_CONE_CUSHION 8
+ #define PM_WAVE_CUSHION 9
+ 
+   // draw modes
+ 
+ #define DM_DIRS 0
+ #define DM_FILES 1
+ #define DM_BOTH 2
+ 
+   // color scheme
+ 
+ #define CS_CYCLIC 0
+ 
+   // color scheme type
+ 
+ #define CST_REGEXP 0
+ #define CST_PERMISSION 1
+ #define CST_USER 2
+ 
+   // find modes
+ 
+ #define FIND_NOTHING 0
+ #define FIND_FILE 1
+ #define FIND_FIRSTDIR 2
+ 
+   // directions
+ 
+ #define HORIZONTAL 0
+ #define VERTIKAL 1
+ 
+ #define DX HORIZONTAL
+ #define DY VERTIKAL
+ 
+   // helpers
+ 
+ #define MAX(x,y) ( (x>y) ? x : y)
+ #define MIN(x,y) ( (x>y) ? y : x)
+ 
+   class QTreeMapArea;
+   class QTreeMapOptions;
+   class QTreeMapWindow;
+ 
+   class QTreeMapWindow : public QMainWindow {
+     Q_OBJECT
+ 
+   public:
+     //QTreeMapWindow(QWidget * parent = 0 );
+     QTreeMapWindow( );
+ 
+     QTreeMapArea *getArea();
+ 
+     public slots:
+ 
+     void setStatusBar(KDirInfo *found);
+     void setDirectoryLabel(KDirInfo *newdir);
+ 
+     //void paintEvent(QPaintEvent *event);
+ 
+   public:
+ 
+   QLabel *dir_name_label;
+   QLabel *info_label;
+   QPushButton *up_button;
+ 
+   QTreeMapArea *graph_widget;
+ 
+   QPushButton *test_button;
+ 
+   QPopupMenu *popup;
+   int popup_id;
+ 
+   QMenuBar *menubar;
+   QStatusBar *statusbar;
+   QToolBar  *toolbar;
+   QPopupMenu *menu_file;
+   QPopupMenu *menu_options;
+   QPopupMenu *menu_paint_mode;
+   QPopupMenu *menu_draw_mode;
+ 
+   QPushButton *zoom_out_button;
+   QPushButton *zoom_in_button;
+ 
+   QRadioButton *radio_flat;
+   QRadioButton *radio_sinus;
+   QRadioButton *radio_cone;
+   //  QRadioButton *radio_flat;
+ 
+   QButtonGroup *radio_group;
+   
+   QScrollView *scrollview;
+   int menu_file_id,menu_options_id;
+ 
+   };
+ 
+   class QTMcolorScheme {
+   public:
+     QString schemeName;
+     QColor  color;
+     int  type;
+     QString  regexp;
+     int  permission_mask;
+     QString user;
+   };
+ 
+   class QTreeMapOptions {
+   public:
+     //KTreeMapOptions();
+     //~KTreeMapOptions();
+     
+     int   color_scheme;
+     int dont_draw_xyd;
+     int dont_descend_xyd;
+     int draw_mode;
+     int paintmode;
+     bool start_direction;
+     int step_width;
+     int paint_size_x;
+     int paint_size_y;
+     int highlight_frame_width;
+     QColor highlight_frame_col;
+     bool draw_text;
+   };
+ 
+   class Cushion {
+   public:
+     Cushion(int xd,int yd);
+     //    Cushion(Cushion *old);
+ 
+     float    r[2][2];
+     float    h;
+     float    f;
+     float    s[2][3];
+   };
+ 
+   class QTreeMapArea : public QWidget {
+     Q_OBJECT
+ 
+   public:
+     //KTreeMap(QWidget *parent=0);
+     QTreeMapArea(QWidget *parent=0);
+     ~QTreeMapArea();
+ 
+     void drawTreeMap(KDirInfo *dutree);
+     void setTreeMap(KDirInfo *dutree);
+     KDirInfo *findClickedMap(KDirInfo *dutree,int x,int y,int findmode);
+ 
+     void paintEvent(QPaintEvent *);
+     void mouseMoveEvent(QMouseEvent *);
+     void mouseDoubleClickEvent(QMouseEvent *);
+     void keyPressEvent(QKeyEvent *event);
+ 
+     void setOptions(QTreeMapOptions *opt);
+     QTreeMapOptions *getOptions();
+     void  resizeEvent( QResizeEvent *ev);
+   private:
+ 
+     void drawDuTree(KDirInfo *dutree, int x0,int y0,int xd0, int yd0, bool direction, int level,Cushion *cushion,int fx=-1,int fy=-1,int find_mode=FIND_NOTHING);
+     void paintEntry(int x0, int y0, int xd, int yd,QString entry_name,bool direction,int level,const QColor &basecolor,int pmode,Cushion *c);
+   
+     void initOptions();
+ 
+   void appendRectlist(QString node_name,int x,int y,int xd,int yd);
+   int getNextRotatingColorIndex();
+   QString&  tellUnit(int size);
+ 
+   QColor& getBaseColor(QString name);
+ 
+   QPainter *painter;
+   QTreeMapOptions *options;
+   QColor default_color;
+   QWidget *widget;
+   QPen mypen;
+   QPixmap offscreen;
+   QPainter *win_painter;
+ 
+   QColor rotate_colors[20];
+   int color_index;
+ 
+   KDirInfo *root_tree;
+ 
+   QToolTip *tooltip;
+ 
+   QVBox *info_box;
+   QHBox *dir_box;
+ 
+   KDirInfo *found_kfileinfo;
+   QColor tooltipBgColor;
+   QColor tooltipFgColor;
+ 
+ 
+   // cushion rendering
+ 
+   void cushion_AddRidge(float x1,float x2,float h,float& s1,float& s2);
+ 
+ #define R_MIN 0
+ #define R_MAX 1
+ 
+   float cushion_rectangle[2][2];
+ 
+ #define D_1 0
+ #define D_2 1
+ 
+   float cushion_surface[1][2];
+ 
+   public slots:
+       void directoryUp();
+   void buttonUp();
+ 
+   signals:
+       void highlighted(KDirInfo *high);
+       void changedDirectory(KDirInfo *newdir);
+   };
+ 
+ } // namespace
+ 
+ 
+ #endif // ifndef QTreeMap_h
+ 
+ 
+ // EOF
diff -c -r -N kdirstat/qtreemaparea.cpp /tmp/kd8/qtreemaparea.cpp
*** kdirstat/qtreemaparea.cpp	Thu Jan  1 01:00:00 1970
--- /tmp/kd8/qtreemaparea.cpp	Thu Jun 21 03:00:53 2001
***************
*** 0 ****
--- 1,699 ----
+ #include <string.h>
+ #include <sys/errno.h>
+ #include <math.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <qtimer.h>
+ #include <kdebug.h>
+ #include <kapp.h>
+ #include <klocale.h>
+ #include "kdirtree.h"
+ #include "kdirtreeview.h"
+ #include "kdirsaver.h"
+ #include "qtreemap.h"
+ #include <qmainwindow.h>
+ //#include <bits/mathcalls.h>
+ 
+ using namespace KDirStat;
+ 
+ QTreeMapArea::QTreeMapArea(QWidget *parent) : QWidget(parent) {
+   initOptions();
+ 
+   offscreen= QPixmap(options->paint_size_x,options->paint_size_y);
+ 
+   painter=new QPainter(&offscreen);
+   win_painter=new QPainter(this);
+ 
+   setMouseTracking(TRUE);
+   root_tree=NULL;
+ 
+   default_color=QColor(255,255,255);
+ 
+   color_index=0;
+   
+   rotate_colors[0]=QColor(255,0,0);
+   rotate_colors[1]=QColor(255,255,0);
+   rotate_colors[2]=QColor(255,0,255);
+   rotate_colors[3]=QColor(0,255,0);
+   rotate_colors[4]=QColor(0,0,255);
+ #define LAST_ROTATING_COL 4
+ 
+   tooltipBgColor=QColor(200,200,0);
+   tooltipFgColor=QColor(0,0,0);
+   this->resize(options->paint_size_x,options->paint_size_y);
+ 
+ 
+ }
+ 
+ int QTreeMapArea::getNextRotatingColorIndex(){
+   color_index++;
+   if(color_index>LAST_ROTATING_COL){
+     color_index=0;
+   }
+   return color_index;
+ }
+ 
+ void QTreeMapArea::setTreeMap(KDirInfo *dutree){
+   root_tree=dutree;
+ 
+   drawTreeMap(dutree);
+ 
+   emit changedDirectory(dutree);
+ }
+ 
+ void QTreeMapArea::initOptions(){
+ 
+   options=new QTreeMapOptions();
+ 
+   options->draw_mode=DM_BOTH;
+   options->paintmode=PM_FLAT;
+   options->start_direction=HORIZONTAL;
+   options->step_width=0;
+   options->paint_size_x=800;
+   options->paint_size_y=500;
+   options->highlight_frame_width=3;
+   options->highlight_frame_col=QColor(255,255,255);
+   options->dont_draw_xyd=1;
+   options->dont_descend_xyd=1;
+   options->draw_text=TRUE;
+   options->color_scheme=CS_CYCLIC;
+ }
+ 
+ void QTreeMapArea::drawTreeMap(KDirInfo *dutree){
+   int x0=0;
+   int y0=0;
+   int xd0=options->paint_size_x;
+   int yd0=options->paint_size_y;
+ 
+   color_index=0;
+ 
+   painter->end();
+   painter->begin(&offscreen);
+   painter->setWindow(x0,y0,xd0,yd0);
+   painter->setFont(QFont( "times",10));
+ 
+   Cushion *cushion=NULL;
+   if(options->paintmode==PM_CUSHION){
+     cushion=new Cushion(xd0,yd0);
+   }
+   else{
+     cushion=NULL;
+   }
+     drawDuTree(dutree,x0,y0,xd0,yd0,options->start_direction,0,cushion);
+ 
+     this->update();
+     this->repaint();
+     //    graph_widget->repaint();
+ }
+ 
+ void QTreeMapArea::drawDuTree(KDirInfo *dutree, int x0,int y0,int xd0, int yd0, bool direction, int level,Cushion *cushion,int fx=-1,int fy=-1,int findmode=FIND_NOTHING){
+   QString node_name=dutree->debugUrl();
+   KDirInfo *sub_nodes=(KDirInfo *)dutree->firstChild();
+   int node_totalsize=dutree->totalSize();
+   Cushion *c=NULL;
+ 
+   //    printf("QTreeMapArea::drawDuTree(%s,%d,%d,%d,%d,dir=%d,level=%d) %d\n",node_name.latin1(),x0,y0,xd0,yd0,direction,level,node_totalsize);
+ 
+   if(xd0>=options->dont_draw_xyd && yd0>=options->dont_draw_xyd){
+   if(fx>=0 && fy>=0){
+     // search mode
+     if( ( x0<=fx && fx<=(x0+xd0) ) && ( ( y0<=fy && fy<=(y0+yd0)) ) ){
+       // mouse coord are inside this entries coordinates
+       found_kfileinfo=dutree;
+       if(findmode==FIND_FIRSTDIR && dutree!=root_tree){
+ 	// we have found the first directory with this coordinates
+ 	return;
+       }
+     }
+     else{
+       // don't descend into this part of tree
+       return;
+     }
+   }
+   else{
+     // not in search mode
+     if(cushion!=NULL){
+       c=new Cushion(*cushion);
+       if(dutree!=root_tree){
+ 	cushion_AddRidge(c->r[direction][0],
+ 			 c->r[direction][1],
+ 			 c->h,
+ 			 c->s[direction][1],
+ 			 c->s[direction][2]);
+       }
+     }
+     else{
+       c=NULL;
+     }
+   }
+ 
+   if((options->draw_mode==DM_FILES || options->draw_mode==DM_BOTH )&& dutree->isFile() /* && (fx==-1 && fy==-1) */ ){
+ 	QColor basecolor;
+ 	//basecolor=getBaseColor(node_name);
+ 	basecolor=QColor(rotate_colors[color_index]);
+ 	int index=getNextRotatingColorIndex();
+ 
+ 	int pmode;
+ 	if((fx>=0 && fy>=0)){
+ 	  // when searching, only draw outline
+ 	    pmode=PM_OUTLINE;
+ 	    if(dutree==found_kfileinfo){
+ 	      paintEntry(x0,y0,xd0,yd0,node_name,direction,level,options->highlight_frame_col,pmode,c);
+ 	  }
+ 	}
+ 	else{
+ 	  // really draw this entry
+ 	  pmode=options->paintmode;
+ 	  paintEntry(x0,y0,xd0,yd0,node_name,direction,level,basecolor,pmode,c);
+ 	}
+ 
+       }
+       else if((options->draw_mode==DM_DIRS || options->draw_mode==DM_BOTH) && ( dutree->isDir() || dutree->isDotEntry())) {
+ 	QColor basecolor=QColor(rotate_colors[color_index]);
+ 	QColor dircolor=QColor(basecolor.red()/3,
+ 			       basecolor.green()/3,
+ 			       basecolor.blue()/3);
+ 	int index=getNextRotatingColorIndex();
+ 
+ 	KDirInfo *dirinfo=(KDirInfo *)dutree;
+ 
+ 	int pmode;
+ 	if(fx>=0 && fy>=0){
+ 	  // draw outline in search mode
+ 	  pmode=PM_OUTLINE;
+ 	  if(dutree==found_kfileinfo){
+ 	    paintEntry(x0,y0,xd0,yd0,node_name,direction,level,options->highlight_frame_col,pmode,c);
+ 	  }
+ 	}
+ 	else{
+ 	  // draw the rectangle
+ 	  pmode=options->paintmode;
+ 	  paintEntry(x0,y0,xd0,yd0,node_name,direction,level,dircolor,pmode,c);
+ 	}
+       }
+       else{
+ 	// we've found a symbolic link or like that
+ 	//printf("neither file nor dir %s\n",node_name.latin1());
+ 	// do nothing?
+       }
+       
+       float x=(float)x0;
+       float y=(float)y0;
+       float xd=0.0;
+       float yd=0.0;
+       float w=0.0;
+ 
+       if(c!=NULL){
+ 	// cushion mode
+ 	w=( c->r[direction][1] - c->r[direction][0] )/((float)node_totalsize);
+       }
+       for(KDirInfo *subtree=sub_nodes;subtree!=NULL;subtree=(KDirInfo *)subtree->next()){
+ 	int subnode_size=subtree->totalSize();
+ 	  if(subnode_size==0){
+ 	    // we do not descend in directories with 0 size
+ 	  }
+ 	  else{
+ 	    float percent_size=((float)subnode_size)/((float)node_totalsize);
+ 	    
+ 	    if(direction==HORIZONTAL){
+ 	      // horizontal
+ 	      xd=(float)xd0;
+ 	      yd=(float)(((float)yd0)*percent_size);
+ 	    }
+ 	    else{
+ 	      // vertikal
+ 	      xd=(float)(((float)xd0)*percent_size);
+ 	      yd=(float)yd0;
+ 	    }
+ 	    bool subdirection=!direction;
+ 	    
+ 	    int sw=options->step_width;
+ 
+ 	    if(c!=NULL){
+ 	      c->r[direction][1]=c->r[direction][0] + ( w*((float)subnode_size) );
+ 	      c->h=c->h*c->f;
+ 	    }
+ 	    
+ 	    drawDuTree(subtree,(int)x,(int)y,(int)(xd-sw),(int)(yd-sw),subdirection,level+1,c,fx,fy,findmode);
+ 
+ 	    if(c!=NULL){
+ 	      c->r[direction][0]=c->r[direction][1];
+ 	    }
+ 
+ 	    if(direction==HORIZONTAL){
+ 	      // horizontal
+ 	      y=y+yd;
+ 	    }
+ 	    else{
+ 	      x=x+xd;
+ 	    }
+ 	  }
+       }
+ 
+       if( dutree->dotEntry()!=NULL ){
+ 	KDirInfo *dotentry=(KDirInfo *)dutree->dotEntry();
+ 	int subnode_size=dotentry->totalSize();
+ 	    float percent_size=((float)subnode_size)/((float)node_totalsize);
+ 	    
+ 	    if(direction==HORIZONTAL){
+ 	      // horizontal
+ 	      xd=(float)xd0;
+ 	      yd=(float)(((float)yd0)*percent_size);
+ 	    }
+ 	    else{
+ 	      // vertikal
+ 	      xd=(float)(((float)xd0)*percent_size);
+ 	      yd=(float)yd0;
+ 	    }
+ 	    bool subdirection=direction;
+ 	    
+ 	    int sw=options->step_width;
+ 
+ 	    drawDuTree(dotentry,(int)x,(int)y,(int)(xd-sw),(int)(yd-sw),subdirection,level,c,fx,fy,findmode);
+       }
+       if(c!=NULL){
+ 	delete c;
+       }
+   }
+ }
+ 
+ void QTreeMapArea::paintEntry(int x0, int y0, int xd, int yd,QString entry_name,bool direction,int level,const QColor &basecolor,int pmode,Cushion *c){
+ 
+ #define MPIX 1
+ 
+   if(xd<=MPIX || yd<=MPIX){
+     if(xd<=MPIX){
+       xd=MPIX;
+     }
+     if(yd<=MPIX){
+       yd=MPIX;
+     }
+   }
+ 
+ #if 0
+       mypen.setColor(QColor(0,255,0));
+       mypen.setWidth( 4);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 
+     painter->drawLine(x0,y0,x0+xd,y0+yd);
+ #endif
+ 
+   if(pmode==PM_OUTLINE){
+     // draw highlighted frames in search mode
+     mypen.setColor(basecolor);
+     mypen.setWidth(options->highlight_frame_width);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 
+     painter->drawRect(x0,y0,xd,yd);
+     //painter->flush();
+   }
+   else if(pmode==PM_FLAT){
+     painter->fillRect(x0,y0,xd,yd,basecolor);
+     //painter->flush();
+   }
+   else if(pmode==PM_PYRAMID){
+     int step=0;
+     int maxstep;
+ 
+     if(xd>yd){
+       maxstep=yd/2;
+     }
+     else{
+       maxstep=xd/2;
+     }
+ 
+     while(step<maxstep){
+       QColor color=QColor((basecolor.red()/maxstep)*(maxstep-step),
+ 			  (basecolor.green()/maxstep)*(maxstep-step),
+ 			  (basecolor.blue()/maxstep)*(maxstep-step));
+       mypen.setColor(color);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+       // why does this drawRect not work?
+       // it draws only the left and upper side line
+       // but not the bottom and right side line
+       painter->drawRect(x0+step,y0+step,xd-step,yd-step);
+       //painter->flush();
+       step++;
+     }
+   }
+   else if(pmode==PM_SIMPLE_CUSHION){
+     for(int w=0;w<xd;w++){
+       for(int h=0;h<yd;h++){
+ 	float ix=sin(((float)w)/((float)xd)*3.14f);
+ 	float iy=sin(((float)h)/((float)yd)*3.14f);
+ 	float i=(ix+iy)/2.0; // intensity as a sin in x/y direction
+ 	QColor newcol=QColor((int)basecolor.red()*i,
+ 			     (int)basecolor.green()*i,
+ 			     (int)basecolor.blue()*i);
+       mypen.setColor(newcol);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 	
+       painter->drawPoint(x0+w,y0+h);
+       //painter->flush();
+       }
+     }
+   }
+   else if(pmode==PM_SQUARE_CUSHION){
+ #define scfunc(x)  (-(x*x)+1.0)
+ 
+     for(int w=0;w<xd;w++){
+       for(int h=0;h<yd;h++){
+ 	float div_x=((float)w)/((float)xd); // range 0...1
+ 	float div_y=((float)h)/((float)yd); // range 0...1
+ 
+ 	float step1_x=(div_x-0.5)*2.0; // range -1...1
+ 	float step1_y=(div_y-0.5)*2.0; // range -1...1
+ 
+ 	float res_x=scfunc(step1_x); // range 0...1...0
+ 	float res_y=scfunc(step1_y);
+ 
+ 	float ix=res_x;
+ 	float iy=res_y;
+ 	float i=(ix+iy)/2.0;
+ 	QColor newcol=QColor((int)basecolor.red()*i,
+ 			     (int)basecolor.green()*i,
+ 			     (int)basecolor.blue()*i);
+       mypen.setColor(newcol);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 	
+       painter->drawPoint(x0+w,y0+h);
+       //painter->flush();
+       }
+     }
+   }
+   else if(pmode==PM_CONE_CUSHION){
+ #define ccfunc(x)  (-fabs(x)+1)
+ 
+     for(int w=0;w<xd;w++){
+       for(int h=0;h<yd;h++){
+ 	float div_x=((float)w)/((float)xd); // range 0...1
+ 	float div_y=((float)h)/((float)yd); // range 0...1
+ 
+ 	float step1_x=(div_x-0.5)*2.0; // range -1...1
+ 	float step1_y=(div_y-0.5)*2.0; // range -1...1
+ 
+ 	float res_x=ccfunc(step1_x); // range 0...1...0
+ 	float res_y=ccfunc(step1_y);
+ 
+ 	float ix=res_x;
+ 	float iy=res_y;
+ 	float i=(ix+iy)/2.0;
+ 	QColor newcol=QColor((int)basecolor.red()*i,
+ 			     (int)basecolor.green()*i,
+ 			     (int)basecolor.blue()*i);
+       mypen.setColor(newcol);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 	
+       painter->drawPoint(x0+w,y0+h);
+       //painter->flush();
+       }
+     }
+   }
+   else if(pmode==PM_WAVE_CUSHION){
+     //#define wcfunc(x)  (sin(((x+1.0)/2.0)*3.14))
+     //#define wcfunc(x)  (((sin(((x+1.0)/2.0)*3.14))/2.0)+0.3)
+ #define wcfunc(x)  (((sin(((x+1.0)/2.0)*3.14))/2.0)+0.3)
+ 
+     for(int w=0;w<xd;w++){
+       for(int h=0;h<yd;h++){
+ 	float div_x=((float)w)/((float)xd); // range 0...1
+ 	float div_y=((float)h)/((float)yd); // range 0...1
+ 
+ 	float step1_x=(div_x-0.5)*2.0; // range -1...1
+ 	float step1_y=(div_y-0.5)*2.0; // range -1...1
+ 
+ 	float res_x=wcfunc(step1_x); // range 0...1...0
+ 	float res_y=wcfunc(step1_y);
+ 
+ 	float ix=res_x;
+ 	float iy=res_y;
+ 	float i=(ix+iy)/2.0;
+ 	QColor newcol=QColor((int)basecolor.red()*i,
+ 			     (int)basecolor.green()*i,
+ 			     (int)basecolor.blue()*i);
+       mypen.setColor(newcol);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 	
+       painter->drawPoint(x0+w,y0+h);
+       //painter->flush();
+       }
+     }
+   }
+   else if(pmode==PM_BITMAP){
+   }
+   else if(pmode==PM_CUSHION && c!=NULL){
+     float Ia=40.0;
+     float Is=215.0;
+     float Lx=0.09759;
+     float Ly=0.19518;
+     float Lz=0.9759;
+ 
+     //for(float iy=c->r[DY][0] + 0.5 ; iy<=( c->r[DY][1] - 0.5 );iy++){
+     //  for(float ix=c->r[DX][0] + 0.5 ; ix<=( c->r[DX][1] - 0.5 );ix++){
+     for(float iy=y0;iy<=y0+yd;iy++){
+       for(float ix=x0;ix<=x0+xd;ix++){
+ 	float nx=-(2*c->s[DX][2]*(ix+0.5) + c->s[DX][1] );
+ 	float ny=-(2*c->s[DY][2]*(iy+0.5) + c->s[DY][1] );
+ 	float cosa=(nx*Lx + ny*Ly + Lz )/sqrt(nx*nx + ny*ny +1.0);
+ 
+ 	float i=Ia+MAX(0,Is*cosa); // range?
+ 	i=i/512.0;
+ 	i=MIN(1.0,i);
+ 	i=MAX(0.0,i);
+ 
+ 	//printf("cushion: i=%f\n",i);
+ 	QColor newcol=QColor((int)basecolor.red()*i,
+ 			     (int)basecolor.green()*i,
+ 			     (int)basecolor.blue()*i);
+       mypen.setColor(newcol);
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 
+ 	painter->drawPoint((int)ix,(int)iy);
+       }
+     }
+       
+   }
+   else{
+     printf("QTreeMapArea::paintEntry no option\n");
+   }
+ 
+   if(pmode!=PM_OUTLINE && options->draw_text){
+     // draw text inside rectangle if text fits
+       mypen.setColor(QColor(255,255,255));
+       mypen.setWidth( 1);
+       painter->setPen( mypen );
+       painter->setBrush( Qt::NoBrush );
+ 
+       //if(direction==VERTIKAL && yd>5){
+     if(xd>=yd && yd>5){
+       int maxlen=xd/4;
+       QString end=entry_name.right(maxlen);
+       painter->drawText(x0,y0+8,end,maxlen);
+     }
+     //else if(direction==HORIZONTAL && xd>5){
+     else if(xd<yd && xd>5){
+       int maxlen=yd/4;
+ 
+       // draw text rotated
+       painter->save();
+       painter->translate(x0,y0);
+       painter->rotate(90);
+ 
+ 
+       QString end=entry_name.right(maxlen);
+       painter->drawText( 0,0,end,maxlen);
+       painter->restore();
+     }
+   }
+ }
+ 
+ 
+ QColor&  getBaseColor(QString name){
+   QColor basecolor;
+ 	/*
+ 	if(isExecutable()){
+ 	  basecolor=NULL;
+ 	}
+ 	else{
+ 	  basecolor=getBaseColorByName(node_name);
+ 	}
+ 	*/
+   basecolor=QColor( rand()&255 , rand()&255, rand()&255 );
+ 
+   return basecolor;
+ }
+ 
+ KDirInfo *QTreeMapArea::findClickedMap(KDirInfo *dutree,int x,int y,int findmode){
+   KDirInfo *found;
+ 
+   found_kfileinfo=NULL;
+ 
+   painter->end();
+ 
+   // copy offscreen to widget
+   win_painter->begin(this);
+   win_painter->drawPixmap(0,0,offscreen,0,0,800,600);
+   win_painter->flush();
+   win_painter->end();
+ 
+     // draw outlines on widget, not on offscreen
+     painter->begin(this);
+     drawDuTree(dutree,0,0,options->paint_size_x,options->paint_size_y,options->start_direction,0,NULL,x,y,findmode);
+ 
+   //printf("FOUND: %s\n",found_kfileinfo->debugUrl().latin1());
+ 
+     int tf=0;
+ 
+     if(y>(options->paint_size_y - 50)){
+       y=y-20;
+     }
+        else{
+ 	 y=y+20;
+        }
+     if(x>(options->paint_size_x/2)){
+       x=x-20;
+       tf=AlignRight;
+     }
+        else{
+ 	 x=x+20;
+        }
+ 
+     int size=found_kfileinfo->totalSize();
+     //QString text=QString(found_kfileinfo->debugUrl()+" size: "+tellUnit(size));
+     
+     QString text; //=found_kfileinfo->debugUrl();
+     text.sprintf("%s %d bytes",found_kfileinfo->debugUrl().latin1(),size);
+ 
+     QRect tt_rect=painter->boundingRect(x,y,-1,-1,tf,text);
+ 
+     painter->fillRect(tt_rect,tooltipBgColor);
+     mypen.setColor(tooltipFgColor);
+     painter->setPen (mypen);
+     painter->drawText(tt_rect,tf,text);
+ 
+   return found_kfileinfo;
+ }
+ 
+ void QTreeMapArea::paintEvent( QPaintEvent *event){
+   if(root_tree!=NULL){
+     QRect event_rect=event->rect();
+ 
+     painter->end(); // end painting on offscreen
+ 
+     // copy offscreen to widget
+     win_painter->begin(this);
+     win_painter->drawPixmap(0,0,offscreen,0,0,800,600);
+     win_painter->flush();
+     win_painter->end();
+ 
+     painter->begin(this);
+   }
+ }
+ 
+ void QTreeMapArea::mouseDoubleClickEvent(QMouseEvent *mouse){
+   if(root_tree!=NULL){
+     int x=mouse->x();
+     int y=mouse->y();
+     if( (0<=x && x<=options->paint_size_x) && (0<=y && y<=options->paint_size_y)){
+       // find the first dir (the first coord. matching entry) the mouse points to
+       KDirInfo *found=findClickedMap(root_tree,x,y,FIND_FIRSTDIR);
+       
+       if(found!=NULL){
+ 	// draw the new map
+ 	setTreeMap(found);
+       }
+     }
+   }
+ }
+ 
+ void QTreeMapArea::mouseMoveEvent(QMouseEvent *mouse){
+   if(root_tree!=NULL){
+     int x=mouse->x();
+     int y=mouse->y();
+     if( (0<=x && x<=options->paint_size_x) && (0<=y && y<=options->paint_size_y)){
+       // find the file (the last coord. matching entry) the mouse points to
+       KDirInfo *found=findClickedMap(root_tree,x,y,FIND_FILE);
+       emit highlighted(found);
+     }
+   }
+ }
+ 
+ void QTreeMapArea::keyPressEvent(QKeyEvent *event){
+   QString key=event->text();
+   if(key==QString("u")){
+     directoryUp();
+   }
+ }
+ 
+ void QTreeMapArea::resizeEvent( QResizeEvent *ev)
+ {
+     // kdDebug() << k_funcinfo << endl;
+  
+     update();   // Trigger repaint on resize
+ }
+ 
+ void QTreeMapArea::buttonUp(){
+   directoryUp();
+ }
+ 
+ void QTreeMapArea::directoryUp(){
+   KDirInfo *parent=(KDirInfo *)root_tree->parent();
+   if(parent!=NULL){
+     setTreeMap(parent);
+   }
+ }
+ 
+ void QTreeMapArea::cushion_AddRidge(float x1,float x2,float h,float& s1,float& s2){
+   s1=s1+4*h*(x2+x1)/(x2-x1);
+   s2=s2-4*h/(x2-x1);
+ }
+ 
+ void QTreeMapArea::setOptions(QTreeMapOptions *opt){
+   delete options;
+ 
+   options=new QTreeMapOptions(*opt);
+ }
+ 
+ QTreeMapOptions *QTreeMapArea::getOptions(){
+   return options;
+ }
+ 
+ QString& QTreeMapArea::tellUnit(int size){
+   QString str;
+   str.sprintf("%d bytes",size);
+   return str;
+ }
+ 
+ QTreeMapArea::~QTreeMapArea()
+ {
+   // to be filled later...
+ }
+ 
+ Cushion::Cushion(int xd,int yd){
+   r[DX][0]=0.0;
+   r[DX][1]=(float)xd;
+   r[DY][0]=0.0;
+   r[DY][1]=(float)yd;
+ 
+   s[DX][1]=0.0;
+   s[DX][2]=0.0;
+   s[DY][1]=0.0;
+   s[DY][2]=0.0;
+ 
+   h=0.5;
+   f=0.75;
+ }
diff -c -r -N kdirstat/qtreemapwindow.cpp /tmp/kd8/qtreemapwindow.cpp
*** kdirstat/qtreemapwindow.cpp	Thu Jan  1 01:00:00 1970
--- /tmp/kd8/qtreemapwindow.cpp	Thu Jun 21 02:41:36 2001
***************
*** 0 ****
--- 1,121 ----
+ #include <string.h>
+ #include <sys/errno.h>
+ #include <math.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <qtimer.h>
+ #include <kdebug.h>
+ #include <kapp.h>
+ #include <klocale.h>
+ #include "kdirtree.h"
+ #include "kdirtreeview.h"
+ #include "kdirsaver.h"
+ #include "qtreemap.h"
+ #include <qmainwindow.h>
+ //#include <bits/mathcalls.h>
+ 
+ using namespace KDirStat;
+ 
+ QTreeMapWindow::QTreeMapWindow(  )  : QMainWindow() {
+ 
+   toolbar= new QToolBar(this);
+ 
+   up_button=new QPushButton("Up",toolbar);
+   zoom_in_button=new QPushButton("ZoomIn",toolbar);
+   zoom_out_button=new QPushButton("ZoomOut",toolbar);
+   dir_name_label=new QLabel("current dirname", toolbar);
+ 
+   this->addToolBar(toolbar,"High!");
+ 
+   menubar=this->menuBar();
+   statusbar=this->statusBar();
+ 
+   QPopupMenu *menu_file=new QPopupMenu(this);
+   menu_file->insertTearOffHandle();
+   menu_file->insertItem("&Save as Bitmap");
+   
+   menu_draw_mode=new QPopupMenu(this);
+   menu_draw_mode->insertItem("Files & Dirs");
+   menu_draw_mode->insertItem("Files");
+   menu_draw_mode->insertItem("Dirs");
+   menu_draw_mode->setCheckable(TRUE);
+ 
+   radio_flat=new QRadioButton(this,"flat");
+   radio_sinus=new QRadioButton(this,"sinus");
+   radio_cone=new QRadioButton(this,"cone");
+ 
+   radio_group=new QButtonGroup(this);
+ 
+   menu_paint_mode=new QPopupMenu(this);
+   menu_paint_mode->insertItem("Flat");
+   menu_paint_mode->insertItem("Sinus");
+   menu_paint_mode->insertItem("faster Sinus");
+   menu_paint_mode->insertItem("Cone");
+   menu_paint_mode->insertItem(radio_group);
+   menu_paint_mode->setCheckable(TRUE);
+ 
+   menu_options=new QPopupMenu(this);
+   menu_options->insertTearOffHandle();
+   menu_options->insertItem("&Paint Mode",menu_paint_mode);
+   menu_options->insertItem("&Draw Mode",menu_draw_mode);
+ 
+   menu_file_id=menubar->insertItem("&File",menu_file);
+   menu_options_id=menubar->insertItem("&Options",menu_options);
+   //  int id=menubar->insertItem("&Help",menu_help);
+ 
+   popup=new QPopupMenu(this);
+   popup_id=popup->insertItem(QString("you"));
+ 
+ #if 0
+   info_box=new QVBox(this);
+   dir_box=new QHBox(info_box);
+ 
+   dir_name_label=new QLabel("toplevel",dir_box);
+   up_button=new QPushButton("Up",dir_box);
+ 
+   info_label=new QLabel("information",info_box);
+ 
+   test_button=new QPushButton("test",info_box);
+ #endif
+ 
+   
+ 
+   scrollview=new QScrollView(this);
+   //graph_widget=new QWidget(scrollview->viewport());
+   graph_widget=new QTreeMapArea(scrollview->viewport());
+   scrollview->addChild(graph_widget);
+ 
+   this->setCentralWidget(scrollview);
+ 
+   //graph_widget=this;
+ 
+ #if 0
+   info_box->show();
+   dir_box->show();
+   info_label->show();
+ #endif
+   graph_widget->show();
+   //graph_widget->resize(options->paint_size_x,options->paint_size_y);
+ 
+   QObject::connect(up_button, SIGNAL(clicked()), graph_widget, SLOT(directoryUp()));
+ 
+   QObject::connect(graph_widget,SIGNAL(highlighted(KDirInfo *)), this, SLOT(setStatusBar(KDirInfo *))  );
+   QObject::connect(graph_widget,SIGNAL(changedDirectory(KDirInfo *)), this, SLOT(setDirectoryLabel(KDirInfo *))  );
+ 
+   this->show();
+   //this->resize(options->paint_size_x,options->paint_size_y);
+   //this->resize(options->paint_size_x,options->paint_size_y);
+ 
+ 
+ }
+ 
+ QTreeMapArea *QTreeMapWindow::getArea(){
+   return graph_widget;
+ }
+ 
+ void QTreeMapWindow::setStatusBar(KDirInfo *found){
+   statusbar->message(found->debugUrl());
+ }
+ void QTreeMapWindow::setDirectoryLabel(KDirInfo *found){
+   dir_name_label->setText(found->debugUrl());
+ }
